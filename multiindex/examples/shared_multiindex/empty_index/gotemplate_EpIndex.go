// Code generated by gotemplate. DO NOT EDIT.

package empty_index

import (
	"unsafe"

	"github.com/eosspark/eos-go/common/container"
	"github.com/eosspark/eos-go/common/container/multiindex"
	. "github.com/eosspark/eos-go/common/container/offsetptr"
)

// template type MultiIndex(SuperIndex,SuperNode,Value,Allocator)

type EpIndex struct {
	super Pointer `*SuperIndex`
	count int
}

const _SizeofEpIndex = unsafe.Sizeof(EpIndex{})

func NewEpIndex() (m *EpIndex) {
	if alloc == nil {
		m = &EpIndex{}
		m.super.Set(unsafe.Pointer(new(ByID)))
	} else {
		m = (*EpIndex)(alloc.Allocate(_SizeofEpIndex))
		m.super.Set(alloc.Allocate(_SizeofSuperIndexEpIndex))
	}

	(*ByID)(m.super.Get()).init(m)
	return m
}

/*generic class*/

const _SizeofSuperIndexEpIndex = unsafe.Sizeof(ByID{})

type EpIndexNode struct {
	super Pointer `*SuperNode`
}

const _SizeofEpIndexNode = unsafe.Sizeof(EpIndexNode{})

func NewEpIndexNode() (n *EpIndexNode) {
	if alloc == nil {
		n = new(EpIndexNode)
	} else {
		n = (*EpIndexNode)(alloc.Allocate(_SizeofEpIndexNode))
	}
	n.super = *NewNil()
	return
}

func (n *EpIndexNode) free() {
	if n != nil && alloc != nil {
		alloc.DeAllocate(unsafe.Pointer(n))
	}
	//else free by golang gc
}

/*generic class*/

//method for MultiIndex
func (m *EpIndex) GetSuperIndex() interface{} { return m.super }
func (m *EpIndex) GetFinalIndex() interface{} { return nil }

func (m *EpIndex) GetIndex() interface{} {
	return nil
}

func (m *EpIndex) Size() int {
	return m.count
}

func (m *EpIndex) Clear() {
	(*ByID)(m.super.Get()).clear()
	m.count = 0
}

func (m *EpIndex) Insert(v item) bool {
	_, res := m.insert(v)
	return res
}

func (m *EpIndex) insert(v item) (*EpIndexNode, bool) {
	fn := NewEpIndexNode()
	n, res := (*ByID)(m.super.Get()).insert(v, fn)
	if res {
		fn.super.Set(unsafe.Pointer(n))
		m.count++
		return fn, true
	}
	return nil, false
}

func (m *EpIndex) Erase(iter multiindex.IteratorType) {
	(*ByID)(m.super.Get()).erase_(iter)
}

func (m *EpIndex) erase(n *EpIndexNode) {
	(*ByID)(m.super.Get()).erase((*ByIDNode)(n.super.Get()))
	m.count--
	n.free()
}

func (m *EpIndex) Modify(iter multiindex.IteratorType, mod func(*item)) bool {
	return (*ByID)(m.super.Get()).modify_(iter, mod)
}

func (m *EpIndex) modify(mod func(*item), n *EpIndexNode) (*EpIndexNode, bool) {
	defer func() {
		if e := recover(); e != nil {
			container.Logger.Error("#multi modify failed: %v", e)
			m.erase(n)
			m.count--
			panic(e)
		}
	}()
	mod(n.value())
	if sn, res := (*ByID)(m.super.Get()).modify((*ByIDNode)(n.super.Get())); !res {
		m.count--
		return nil, false
	} else {
		n.super.Set(unsafe.Pointer(sn))
		return n, true
	}
}

func (n *EpIndexNode) GetSuperNode() interface{} { return (*ByIDNode)(n.super.Get()) }
func (n *EpIndexNode) GetFinalNode() interface{} { return nil }

func (n *EpIndexNode) value() *item {
	return (*ByIDNode)(n.super.Get()).value()
}

/// IndexBase
type EpIndexBase struct {
	final Pointer `*MultiIndex`
}

type EpIndexBaseNode struct {
	final Pointer `*MultiIndexNode`
	pv    Pointer `*Value`
}

const _SizeofEpIndexBaseNode = unsafe.Sizeof(EpIndexBaseNode{})

func NewEpIndexBaseNode(final *EpIndexNode, pv item) (mn *EpIndexBaseNode) {
	if alloc == nil {
		mn = new(EpIndexBaseNode)
		mn.pv.Set(unsafe.Pointer(&pv))
	} else {
		mn = (*EpIndexBaseNode)(alloc.Allocate(_SizeofEpIndexBaseNode))
		pvAlloc := alloc.Allocate(unsafe.Sizeof(pv))
		mn.pv.Set(pvAlloc)
		*(*item)(pvAlloc) = pv
	}
	mn.final.Set(unsafe.Pointer(final))
	return
}

func (n *EpIndexBaseNode) Free() {
	if n != nil && alloc != nil {
		alloc.DeAllocate(n.pv.Get())
		alloc.DeAllocate(unsafe.Pointer(n))
	}
}

func (i *EpIndexBase) init(final *EpIndex) {
	i.final.Set(unsafe.Pointer(final))
}

func (i *EpIndexBase) clear() {}

func (i *EpIndexBase) GetSuperIndex() interface{} { return nil }

func (i *EpIndexBase) GetFinalIndex() interface{} { return i.final }

func (i *EpIndexBase) insert(v item, fn *EpIndexNode) (*EpIndexBaseNode, bool) {
	return NewEpIndexBaseNode(fn, v), true
}

func (i *EpIndexBase) erase(n *EpIndexBaseNode) {
	if !n.pv.IsNil() {
		if alloc != nil {
			alloc.DeAllocate(n.pv.Get())
		}
		n.pv.Set(nil)
	}
	n.Free()
}

func (i *EpIndexBase) erase_(iter multiindex.IteratorType) {
	container.Logger.Warn("erase iterator doesn't match all index")
}

func (i *EpIndexBase) modify(n *EpIndexBaseNode) (*EpIndexBaseNode, bool) {
	return n, true
}

func (i *EpIndexBase) modify_(iter multiindex.IteratorType, mod func(*item)) bool {
	container.Logger.Warn("modify iterator doesn't match all index")
	return false
}

func (n *EpIndexBaseNode) value() *item {
	return (*item)(n.pv.Get())
}
